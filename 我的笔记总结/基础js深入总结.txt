	基础js深入总结
一、数据类型：
	1、分类：（分两大类）
		（1）基本类型（也叫值类型）
			* Number: 任意数值
			* String: 任意文本
			* Boolean: true/false
			* undefined: undefined
			* null: null
		（2）对象类型（也叫引用类型）
			* Object: 任意对象（一般用于存无序的数据）
			* Array: 特别的对象类型(下标/内部数据有序)（一般用于存有序的数据）
			* Function: 特别的对象类型(可执行)（一般用于存重复执行的代码）			
	2、判断类型：
		（1）typeof: 返回的是数据类型的字符串表达式
			1) 可以区别：数值、字符串、布尔值、undefined、function
			2）不能区别：null与对象，一般对象与数组
		（2）instanceof:
			专门用来判断对象数据的具体类型：Object,Array与Function
		（3）=== ：全等
			可以判断： undefined 和 null  （因为undefined 和 null都是只有一个值，所以可以用全等判断）
			
		// 1、基本类型的判断例子
		  var a
		  console.log(a, typeof a, a === 'undefined')  // undefined "undefined" false
		  console.log(a, typeof a, a === undefined)  // undefined "undefined"  true
		  console.log(a === typeof a)   // false 因为a是undefined，后者是"undefined"
		  a = 6
		  console.log(typeof a, typeof a === 'number')   // number true
		  a = 'hello world'
		  console.log(typeof a, typeof a === 'string')    // string true
		  a = true
		  console.log(typeof a, typeof a === 'boolean')   //  boolean true
		  a = null
		  console.log(typeof a)  // object
		  console.log(a === null)  // true    null 不能用 typeof 来检查，要用全等来检查
  
		 // 2、对象类型的例子
		  var b1 = {
			  b2: [2, 'abc', console.log],
			  b3: function () {
				  console.log('b3()')
			  }
		  }
		  console.log(b1 instanceof Object, typeof b1) // true "object"
		  console.log(b1.b2 instanceof Array, typeof b1.b2) // true "object"
		  console.log(b1.b3 instanceof Function, typeof b1.b3) // true "function"

		  console.log(typeof b1.b2[2]) // function  注意console.log(),log是个函数
		  /*
			b1.b2[2]('aaa')调用了console.log输出了aaa，但是console.log()函数没有返回值，
			  即为undefined，console.log(b1.b2[2]('aaa'))最后相当于执行console.log(undefined)
			  所以最后输出的是undefined
		   */
		  console.log(b1.b2[2]('aaa')) // aaa   undefined
	3、undefined与null的区别
		undefined代表没有赋值；null代表赋值了, 只是值为null
	4、什么时候给变量赋值为null呢?
		（1）在程序的前面：起暗示作用，后面会赋值为对象，进行计算，处理产生对象并保存
		* var a = null //a将指向一个对象, 但对象此时还没有确定（初始化变量a）
		（2）中间给b赋值
			b = {
					name: 'Tom'，
					age: 12
			  }
		（3）在程序的后面：b指向的对象就没有了指向它的引用，就称为垃圾对象从而被垃圾器回收
				但是因为b时全局变量，b并没有释放，而是一致存在,只是之前被对象占用的内存被释
				放了，其他数据可以来使用b所在的内存了
		* a = null //让a指向的对象成为垃圾对象 （结束时将a=null，释放资源）
	5、严格区别变量类型与数据类型?
		  * js的变量本身是没有类型的, 变量的类型实际上是变量内存中数据的类型
		  * 变量类型:
			* 基本类型: 保存基本类型数据的变量
			* 引用类型: 保存对象地址值的变量
		  * 数据对象
			* 基本类型
			* 对象类型

二、数据-变量-内存
	1. 什么是数据?
		* 存储于内存中代表特定信息的'东东', 本质就是0101二进制
		* 具有可读和可传递的基本特性：一般等号左边的就是写操作，其他的都是读操作
		* 万物(一切)皆数据, 函数也是数据（如何证明函数也是数据：函数传一个函数）
		* 程序中所有操作的目标: 都是数据
			* 算术运算
			* 逻辑运算
			* 赋值
			* 调用函数传参
	2. 什么是内存?
	  * 内存条通电后产生的存储空间(临时的)
	  * 产生和死亡: 内存条(集成电路板)==>通电==>产生一定容量的存储空间==>存储各种数据==>断电==>内存全部消失
	  * 内存的空间是临时的, 而硬盘的空间是持久的
	  * 一块内存包含2个数据
		* 内部存储的数据(一般数据/地址数据)
		* 内存地址值数据
	  * 内存分类
		* 栈: 全局变量, 局部变量 (空间较小)
		* 堆: 对象 (空间较大)
	3. 什么是变量?
	  * 值可以变化的量, 由变量名与变量值组成
	  * 一个变量对应一块小内存, 变量名用来查找到内存, 变量值就是内存中保存的内容
	4. 内存,数据, 变量三者之间的关系
	  * 内存是一个容器, 用来存储程序运行需要操作的数据
	  * 变量是内存的标识, 我们通过变量找到对应的内存, 进而操作(读/写)内存中的数据
	  
	5、问题: var a = xxx, a内存中到底保存的是什么?
		这要取决于xxx的值是什么类型的，举例说明：
			var a = 3  // a保存的3， 是基本类型变量
			a = {}  //ａ　保存的是{}的地址值，是与引用类型变量
			var b = 'abc'
			a = b　// a 保存的时 b 的值（'abc'）,是基本类型变量
			b = []
			a = b  // a 保存的是b的值（地址值），是引用类型变量
	6、关于引用变量赋值问题
		* 2个引用变量指向同一个对象, 通过一个引用变量修改对象内部数据, 另一个引用变量也看得见
			  var obj1 = {}
			  var obj2 = obj1
			  obj2.name = 'Tom'
			  console.log(obj1.name)   // Tom
			  function f1(obj) {  // obj = obj2 ,那么此时obj/obj1/obj2三个变量都指向同一个对象{}
				obj.age = 12    // 任意一个引用变量来修改对象内部的数据，其他两个引用变量也看得见
			  }
			  f1(obj2)
			  console.log(obj1.age)   // 12
			
		* 2个引用变量指向同一个对象,让一个引用变量指向另一个对象, 另一个引用变量还是指向原来的对象，
				修改其中一个变量不会引起另一个变量的变化
			   var obj3 = {name: 'Tom'}
			   var obj4 = obj3
			   obj3 = {name: 'JACK'}
			   console.log(obj4.name)    // Tom ，obj4还是指向{name: 'Tom'}对象，而obj3指向的是{name: 'JACK'}对象
			   function f2(obj) {  // obj = obj4
				 obj = {name: 'Bob'}  // 这一步将 obj 切断对obj4指向的对象的引用，重新指向另一个新对象{name: 'Bob'}
			   }
			   f2(obj4)
			   console.log(obj4.name)   // Tom
	7、问题: 在js调用函数时传递变量参数时, 是值传递还是引用传递
		  * 只有值传递, 没有引用传递, 传递的都是变量的值, 只是这个值可能是基本数据, 也可能是地址(引用)数据
		  * 如果后一种看成是引用传递, 那就值传递和引用传递都可以有
				  function f(a) {
					console.log(a)  // 4
				  } 
				  var n = 4
				  f(n) //传递的是n的值 --->值传递
				  
				  function f2(a) {
					a.name = 'atguigu'
				  }
				  n = {}
				  f2(n) // 如果说是值传递（传递的是变量的值），如果说是引用传递（传递的n的值是引用类型）
				  console.log(n.name)  // atguigu
	8、问题: JS引擎如何管理内存?
		  （1） 内存生命周期
				1). 分配需要的内存
				2). 使用分配到的内存
				3). 不需要时将其释放/归还
		  （2） 释放内存
				* 为执行函数分配的栈空间内存: 函数执行完自动释放
				* 存储对象的堆空间内存: 当内存没有引用指向时, 对象成为垃圾对象, 垃圾回收器后面就会回收释放此内存
		  （3）举例：
				  var obj = {}
				  obj = null // obj变量因为是全局的所以还在，{}对象所占用的内存被释放了，其他数据可以使用该内存
				  function fn () {
					var a = 3
					var b = {}
				  }
				  fn() // 执行完后b，c是立即释放，c指向的对象{}在后面的某个时刻被垃圾器回收释放
三、对象
	1. 什么是对象?
		  * 代表现实中的某个事物, 是该事物在编程中的抽象
		  * 多个数据的集合体(封装体)
		  * 用于保存多个数据的容器
	2. 为什么要用对象?
		* 便于对多个数据进行统一管理
	3. 对象的组成
		  * 属性
			* 代表现实事物的状态数据
			* 由属性名和属性值组成
			* 属性名都是字符串类型, 属性值是任意类型
		  * 方法
			* 代表现实事物的行为数据
			* 是特别的属性==>属性值是函数
	4. 如何访问对象内部数据?
		  * .属性名: 编码简单, 但有时不能用（比如属性名中有其他特殊符号，或者属性名是个变量）
		  * ['属性名']: 编码麻烦, 但通用（不管属性名是什么样子的都可以使用）
				// 创建对象
				  var p = {
					name: 'Tom',
					age: 12,
					setName: function (name) {
					  this.name = name
					},
					setAge: function (age) {
					  this.age = age
					}
				  }
				// 访问对象内部数据
				  console.log(p.name, p['age'])  // Tom 12
				  p.setName('Jack')
				  p['setAge'](23)
				  console.log(p['name'], p.age)   // Jack  23
	5、问题: 什么时候必须使用['属性名']的方式?
			* 属性名不是合法的标识名 （即属性名中有其他特殊符号）
			* 属性名不确定 （即属性名是个变量）
				 p['content-type'] = 'text/json'
				 var prop = 'xxx'
				 var value = 123
				 p[prop] = value
				 console.log(p['content-type'], p[prop])    // text/json 123
  
	6、对象的面试题
		/*
		  因为属性名必须是字符串，所以当传入的属性名是个变量，值是对象时，内部会调用该对象的toString()方法
		  来得到字符串的属性名：a['[object Object]'] = 4,a[obj1]和a[obj2]通过toString()转换后都是
		  得到相同的[object Object]，所以它们分别赋值实际是在给[object Object]重新赋值，如果属性名
		  是个变量，值是数组，那就看数组是否一样，如果一样后面就是赋值操作，如果不一样那就互不影响
		*/
			  var a = {}
			  var obj1 = {n: 2}
			  var obj2 = {m: 3}
			  console.log(obj1.toString())   // [object Object]
			  a[obj1] = 4   //  a['[object Object]'] = 4
			  a[obj2] = 5   //  a['[object Object]'] = 5 在这里只是相当于给a['[object Object]']重新赋值了
			  console.log(a[obj1]) // 5
			  var arr1 = [1, 2]   // arr1保存的是数组[1, 2]的地址值，
			  var arr2 = [3, 4]   // arr2保存的是数组[3, 4]的地址值
			  var arr3 = [3, 4]    // arr3保存的是数组[3, 4]的地址值
			  a[arr1] = 6    // 相当于a['[1, 2]的地址值'] = 6
			  a[arr2] = 8    // 相当于a['[3, 4]的地址值'] = 8
			  a[arr3] = 10   // 相当于a['[3, 4]的地址值'] = 10  ,即也是给a['[3, 4]的地址值']重新赋值
			  console.log(a[arr1])   // 6
			  console.log(a[arr2])   // 10  后面给a['[3, 4]的地址值']重新赋值了
  
四、函数
	1. 什么是函数?
		  * 具有特定功能的n条语句的封装体
		  * 只有函数是可执行的, 其它类型的数据是不可执行的
		  * 函数也是对象
	2. 为什么要用函数?
		  * 提高代码复用
		  * 便于阅读和交流
	3. 如何定义函数?
		  * 函数声明
		  * 表达式
		   function f1 () { // 函数声明
			 console.log('f1()')
		  }
		   var f2 = function () { // 表达式
			 console.log('f2()')
          }
	4. 如何调用(执行)函数?
		  * test()   直接调用
		  * new test()  new 调用
		  * test.call/apply(obj)  通过函数的对象的call、applay()调用
	5、如何证明函数也是对象？
		  function fn() {

		  }
		  console.log(fn instanceof Object) //  true  是Object类型的实例
		  console.log(fn.prototype) // {constructor: ƒ}  内部有属性
		  console.log(fn.toString)  // ƒ toString() { [native code] }  内部有方法
		  console.log(fn.call) // ƒ call() { [native code] } 内部有方法
		  fn.t1 = 'atguigu' // 可以添加属性
		  fn.t2 = function () { // 可以添加方法
			console.log('t2() '+this.t1)    // t2() atguigu
		  }
		  fn.t2()
	6. 什么函数才是回调函数?
		  * 自己定义的
		  * 自己没有直接调用
		  * 但最终它执行了(在特定条件或时刻)
	7. 常见的回调函数?
		  * DOM事件函数
		  * 定时器函数
		  * ajax回调函数(后面学)
		  * 生命周期回调函数(后面学)
		   //1. DOM事件函数
			  var btn = document.getElementById('btn')
			  btn.onclick = function () {
				alert(this.innerHTML)
			  }

		   //2. 定时器函数
			  setInterval(function () {
				alert('到点啦!')
			  }, 2000)
	8、IIFE 
		* 全称: Immediately-Invoked Function Expression 立即调用函数表达式
		* 别名: 匿名函数自调用（自调函数）
		* 作用：
		  * 隐藏内部实现
		  * 不污染外部命名空间
			  (function (i) {
					var a = 4
					function fn() {
					  console.log('fn ', i+a)   //   fn  7
					}
					fn()
			  })(3)
			  
	9、函数中的 this 
		本质上任何函数在执行时都是通过某个对象调用的
		（1）this 是什么？
			  * 一个关键字, 一个内置的引用变量
			  * 在函数中都可以直接使用this
			  * this代表调用函数的当前对象
			  * 在定义函数时, this还没有确定, 只有在执行时才动态确定(绑定)的
		（2）如何确定this的值?
			  * test() ：  window
			  * obj.test() ：  obj
			  * new test() ：  新创建的实例对象
			  * test.call(obj) ：  obj
			  * DOM 事件回调函数 ：绑定事件的 dom 元素
			  * 定时器回调函数 ：window
			  * ajax 回调函数 ： window
			  * 数字遍历相关方法(map,forEach,filter)回调函数 ： window
			  
							function Person(color) {
								console.log(this)
								this.color = color;
								this.getColor = function () {
								  console.log(this)
								  return this.color;
								};
								this.setColor = function (color) {
								  console.log(this)
								  this.color = color;
								};
							}
							  Person("red"); //this是谁?   window
							  var p = new Person("yello"); //this是谁?  p
							  p.getColor(); //this是谁?  p
							  var obj = {};
							  p.setColor.call(obj, "black"); //this是谁?  obj
							  var test = p.setColor;
							  test(); //this是谁?    window
							  function fun1() {
								function fun2() {
								  console.log(this);
								}
								fun2(); //this是谁?    window
							  }
							  fun1();
							  
-----------------------------------------------------------------------------------------------------------------						  
		函数高级 	
一、函数高级
	1、原型与原型链
		（1） 函数对象的prototype属性(图)
			  * 每个函数都有一个prototype属性, 它默认指向一个Object空对象(即称为: 原型对象)
					console.log(Date.prototype, typeof Date.prototype) 
					//{constructor: ƒ, toString: ƒ, toDateString: ƒ, toTimeString: ƒ, toISOString: ƒ, …} "object"
					function fn() {}
					console.log(fn.prototype, typeof fn.prototype)  // {constructor: ƒ} "object"
			  * 原型对象中有一个属性constructor, 它指向函数对象，  prototype是引用类型变量
					console.log(Date.prototype.constructor===Date)   // true
					console.log(fn.prototype.constructor===fn)   // true
		（2） 给原型对象添加属性(一般都是方法)
			  * 作用: 函数的所有实例对象自动拥有原型中的属性(方法)
					  function F() { }
					  F.prototype.age = 12 //添加属性
					  F.prototype.setAge = function (age) { // 添加方法
						  console.log(this)   // f
						this.age = age
					  }
					  // 创建函数的实例对象
					  var f = new F()
					  console.log(f.age)   // 12
					  f.setAge(23)
					  console.log(f.age)   // 23
					  
  